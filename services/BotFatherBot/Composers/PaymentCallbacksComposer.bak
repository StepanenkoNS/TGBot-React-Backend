import { Composer } from "grammy";
import { EnqueueAsyncSendMessage } from "services/Types/Telegram/EnqueueSendMessageTypes";
import { TelegramSendMethods } from "services/Types/Telegram/TelegramMethods";
import { enqueueTelegramMessageIntoIncomingMessages } from "services/Utils/TelegramHelper/EnqueueAsyncMessage";
 // @ts-ignore: Unreachable code error
import * as i18n from "/opt/i18n";


export class PaymentCallbacksComposer extends Composer<MyContext> {

    private chatConfigurator: ChatConfigurator;
    private async bindedConfirmPayment(ctx:any){
        const matches = ctx.update.callback_query.data.match(/(?<=(^subscription[\/]confirm[\/])).*/);
        const transactionId = matches![0];

       
        const smiley = "\u{2705}";
        let transactionResult =  ctx.update.callback_query.message?.text+
        '\n\n______________\n'+smiley+'<b>Approved by: '+ this.chatConfigurator.ChatId() +'\n'+
                'at '+new Date().toISOString()+'</b>'
        if (ctx.update.callback_query.message?.entities  && ctx.update.callback_query.message?.entities[0] && ctx.update.callback_query.message?.entities[0].type=='text_link') {
            let url = ctx.update.callback_query.message?.entities[0].url;
            transactionResult = `<a href="${url}"> </a>`+transactionResult ;
        }
        
        const userLanguage = await ChatConfigurator.GetUserLanguageSettings(this.chatConfigurator.BotId(), this.chatConfigurator.ChatId());
        const messageToSend = i18n.getTranslation("buy.paymentMessage.subscriptionConfirmed", {ns:"translation", lng: userLanguage.menuLanguage})

        const res = await this.chatConfigurator.CreateSubscriptionOnSuccessfulTransaction(transactionId!, transactionResult);
        const message:EnqueueAsyncSendMessage = {
            botId: this.chatConfigurator.BotId(),
            chatIds: [res],
            method: TelegramSendMethods.sendMessage,
            text: messageToSend,
            sender: this.chatConfigurator.ChatId(),
            disable_web_page_preview: true,
        };
        await enqueueTelegramMessageIntoIncomingMessages(message);
                
        ctx.editMessageText(transactionResult, {
            disable_web_page_preview:false,
            //reply_markup: ctx.update.callback_query.message?.reply_markup,
            parse_mode: 'HTML'
        });
    }

    private async bindedRejectPayment(ctx:any){
        const matches = ctx.update.callback_query.data.match(/(?<=(^subscription[\/]reject[\/])).*/);
        const transactionId = matches![0];

       
        const smiley = "\u{274C}";
        let transactionResult =  ctx.update.callback_query.message?.text+
        '\n\n______________\n'+smiley+'<b>Rejected by: '+ this.chatConfigurator.ChatId() +'\n'+
                'at '+new Date().toISOString()+'</b>'
        if (ctx.update.callback_query.message?.entities  && ctx.update.callback_query.message?.entities[0] && ctx.update.callback_query.message?.entities[0].type=='text_link') {
            let url = ctx.update.callback_query.message?.entities[0].url;
            transactionResult = `<a href="${url}"> </a>` + transactionResult ;
        }
        const item = await this.chatConfigurator.GetSubscriptionPaymentTransaction(transactionId);
        if (item){
            const PK = item.PK as string;
            //const userMatches = PK.match(/(?<=\#USER\#)(.*)(?=\#TRANSACTION#SUBSCRIPTION)/);
            const userId = item.chatId.toString();
            ctx.session.adminSendRejectTransactionMessage = {
                chatIds: [userId],
                transactionId: transactionId,
                updateMessageText: transactionResult,
                message_id: ctx.update.callback_query.message?.message_id!,
                

            }



            await ctx.conversation.enter("bound SendRejectSubscriptionPaymentToChatUser");

        }
    }

    constructor(chatObject:ChatConfigurator){
        super();

        this.chatConfigurator = chatObject;

        this.callbackQuery(/^(subscription[\/]confirm[\/])/, this.bindedConfirmPayment.bind(this));
        this.callbackQuery(/^(subscription[\/]reject[\/])/, this.bindedRejectPayment.bind(this)); 
            
    }
    
}